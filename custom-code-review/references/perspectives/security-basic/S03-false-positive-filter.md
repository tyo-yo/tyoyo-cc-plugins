# False Positiveフィルタリング

**ID**: S03
**カテゴリ**: セキュリティ（基本）
**優先度**: Tier 1（必須）
**信頼度基準**: 80以上のみ報告

---

## 参照元

- [Piebald-AI/claude-code-system-prompts](https://github.com/Piebald-AI/claude-code-system-prompts)
- [Security Review Command](https://github.com/Piebald-AI/claude-code-system-prompts/blob/main/security-review.md)

---

## 概要

セキュリティスキャンにおける誤検知（False Positive）を体系的にフィルタリングし、信頼度の高い指摘のみを報告します。

セキュリティツールやレビューでは過検出が一般的ですが、誤検知が多いとノイズとなり、真の脆弱性を見逃すリスクが高まります。Piebald-AIのアプローチでは、17以上の明示的な除外ルールと、信頼度スコアリング（8/10以上のみ報告）により、高品質なセキュリティレビューを実現します。

---

## チェック内容

### 2段階検証プロセス

1. **初期検出（Phase 1）**: 過検出を許容して幅広く検出
2. **並列検証（Phase 2）**: 各問題を独立したサブタスクで検証

### ハード除外ルール（17+パターン）

以下は報告対象外:

1. **DOS脆弱性**: サービス拒否攻撃（メモリ/CPU枯渇、レート制限）
2. **ディスク上のシークレット**: 他の方法で保護されている場合
3. **レート制限の欠如**: アプリケーションレベルの問題
4. **メモリ/CPU枯渇**: リソース管理の問題
5. **影響が不明確な入力検証**: 具体的な攻撃シナリオがない場合
6. **GitHub Actionsワークフローのサニタイゼーション**: 明確に悪用可能でない限り
7. **セキュリティ強化措置の欠如**: 防御層が1つ欠けているだけの場合
8. **理論的な競合状態**: 実際の悪用が困難な場合
9. **古いサードパーティライブラリ**: Dependabotで対応すべき
10. **メモリセーフ言語のメモリ安全性**: Rust、Go、Python等
11. **ユニットテストファイル**: テストコード自体の脆弱性
12. **ログの改ざん（Log Spoofing）**: 実際の影響が限定的
13. **パスのみ制御可能なSSRF**: 完全なURL制御がない場合
14. **AIプロンプトへのユーザーコンテンツ**: プロンプトインジェクションが理論的
15. **正規表現インジェクション**: 具体的な攻撃経路がない場合
16. **正規表現DOS（ReDoS）**: 実際の影響が限定的な場合
17. **ドキュメントの問題**: セキュリティ実装ではなくドキュメント不備

### 先例ベースの評価

以下は一般的に安全と見なす:

- **UUIDs**: 推測不可能として扱う
- **環境変数**: 信頼された入力源
- **CLIフラグ**: 信頼された入力源
- **React/Angular**: 一般的にXSS安全（unsafe APIs除く）
- **ORM（Sequelize、TypeORM等）**: パラメータ化クエリで安全
- **フレームワークのサニタイザー**: 正しく使用されていれば安全

### 信頼度スコアリング

- **9-10点**: 確実な悪用経路、即座に報告
- **8-9点**: 明確な脆弱性、既知の悪用方法あり
- **7-8点**: 疑わしいパターン、条件付きで悪用可能
- **7点未満**: 報告しない（理論的すぎる）

---

## 適用基準

### 使用する場合

- ✅ セキュリティスキャン後の検証
- ✅ 自動ツールの結果レビュー
- ✅ セキュリティ観点からの最終チェック
- ✅ 高リスク領域のコード変更

### 使用しない場合

- ❌ 初回の脆弱性検出フェーズ（過検出を許容）
- ❌ セキュリティに無関係なコード変更

---

## 具体例

### ❌ 報告すべきでない: 環境変数の使用

```python
# 環境変数は信頼された入力
import os
api_key = os.environ.get('API_KEY')
response = requests.get(f"https://api.example.com/data?key={api_key}")
```

**理由**: 環境変数は管理者が制御する信頼された入力源であり、脆弱性ではない。

---

### ✅ 報告すべき: ユーザー入力の直接使用

```python
# ユーザー入力を直接APIに送信
user_input = request.args.get('query')
response = requests.get(f"https://api.example.com/search?q={user_input}")
```

**問題点**: ユーザー入力が検証されずに外部APIに送信され、SSRFや他の攻撃の可能性がある。
**信頼度**: 8/10（具体的な攻撃シナリオあり）

---

### ❌ 報告すべきでない: Reactでの安全な使用

```javascript
// Reactは自動的にエスケープ
function UserProfile({ username }) {
  return <div>Hello, {username}!</div>;
}
```

**理由**: ReactはデフォルトでXSS攻撃を防ぐため、安全なAPIを使用していれば安全。

---

### ❌ 報告すべきでない: 理論的な競合状態

```python
# マルチスレッド環境での変数アクセス
class Counter:
    def __init__(self):
        self.count = 0

    def increment(self):
        self.count += 1  # 理論的には競合状態
```

**理由**: 実際の悪用が困難で、セキュリティリスクより保守性の問題。信頼度6/10未満。

---

## 2026年トレンド

AI生成コードの普及により、セキュリティスキャンの誤検知率が増加傾向:

- **過剰な検証**: AIが保守的に全てをフラグする傾向
- **コンテキスト不足**: フレームワークの安全機能を理解していない
- **先例の無視**: 既存の安全パターンを認識しない

False Positiveフィルタリングの重要性が一層高まっています。

---

## 関連観点

- [S01] セキュリティ脆弱性（基本）
- [S02] 一般的な脆弱性パターン
- [S04] 先例ベースの評価
- [S06] 攻撃者モデリング
