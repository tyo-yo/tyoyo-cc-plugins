# 実装リファクタリングルール

RED-GREEN-REFACTOR サイクルの REFACTOR フェーズ（実装コード専用）。

## 過剰な防御・バリデーション

- システム境界（ユーザー入力、外部 API）でのみバリデーションする。内部コード間の呼び出しでは型を信頼する
- 内部関数の先頭に `if arg is None: raise ValueError` のようなガードを書かない
- `if x is not None` が論理的に常に True になるガード句は無駄。コードの流れを追って本当に None になりうるか確認する
- 型システムや上流のバリデーションが保証している不変条件を、下流で再チェックしない
- Pydantic で検証済みの値をビジネスロジック層で再検証しない
- 「どのレイヤーがこの制約の責務を持つか」を明確にし、1箇所でのみ検証する
- `Optional` を返す関数が本当に `None` を返しうるか確認する。常に値が存在するなら `Optional` を外す

## コードの簡潔さ

- 1箇所からしか呼ばれないヘルパー関数は作らない。ロジックをインラインにする。ただし、それ自体が独立した概念・責務を持つ処理単位（関数名が意図を正確に表現でき、インライン化すると親関数の抽象レベルが乱れる場合）は分離を許容する
- 一度しか使わない操作のためにユーティリティモジュールを作らない
- 「将来再利用されるかも」で関数を切り出さない
- 実質2行のラッパー関数なら、その存在意義を問う: 「この関数は存在に値するか？」
- 実装が1つしかない ABC / Protocol を作らない。2つ目の実装が出てから抽象化する
- 可読性が維持される限り、行数は少ない方が良い。似たような3行 > 早すぎる抽象化
- 実装後、明快さを損なわずに短くできる箇所を積極的に探す
- 未使用のフィールド、関数、インポートは議論不要で即削除
- 「後で使うかも」なコードは削除。実際に必要になったら書き直す
- リファクタリング後、古い構造から残った孤立した変数名がないか確認する

## コメント

- コードが既に語っていることをコメントしない（`build_tools()` の上に `# ツール構築` は不要）
- 意図がコードから明らかでない場合のみコメントする
- プロジェクトの既存コメント密度に合わせる
- コメントにも DRY を適用: 同じ説明を複数箇所に書かない
- セクション区切りコメント（`# --- Helpers ---`）はプロジェクトで使われていない限り入れない

## 命名

- ファイル名は中身と一致させる: `handler.py` は曖昧 → `tool_handlers.py` が具体的
- 関数名は実際の動作と一致させる: `collect()` がストリーム処理になったなら `run_stream()` に変える
- 関数名を変更したら、関連する変数名もすべて更新する（例: `collected` → `stream_result`）
- `TC`（`tool_call` の略）のようなプロジェクト慣習にない略語は使わない
- `data`、`result`、`info`、`handler` のような汎用名を修飾する: `tool_result`、`search_handler`

## 既存パターン優先

- 新しいコードを書く前に `.kiro/steering/` 配下のステアリングファイルを確認し、プロジェクト規約に従う
- コードベース内に類似機能がないか検索する
- 同じレイヤー・同じライブラリを使う他の実装者のコードを参照実装として確認する
- ディレクトリ配置、ファイル命名、モジュール構成を合わせる
- パターンが存在する場合（エラーハンドリング、ロギング、ストリーミング）、そのまま従う
- 関数の引数と戻り値には `dict[str, Any]` ではなく SDK/フレームワークの型を使う
- 動作する最も汎用的な親クラスの型を受け取る

## エラーハンドリング

- 既存の `logger.warning` / `logger.error` パターンを確認し、同じレベルとフォーマットに合わせる
- シンプルな try-except パターンを使う。エラーリカバリを過剰設計しない
- 正当な理由なくカスタム例外階層を導入しない
- `except E as e: raise Custom(str(e))` のような情報を失う例外変換をしない
- エラーをキャッチしてデフォルト値を返すサイレントフォールバックを避ける。問題を隠すだけ
- リトライロジックは本当に必要な箇所のみ。冪等でない操作のリトライは危険

## 設計判断

- 非自明な設計選択には1行コメントで理由を書く（例: 「ディレクトリ走査の重複回避のためシングルトン」）
- 具象クラスに依存する場合、本質的な依存理由を説明する
- 既存パターンから逸脱する場合、その理由をドキュメントする

## 構造改善

- 引数が4つ以上の関数 → dataclass にまとめることを検討する
- ブール引数は関数の分割を検討する
- `if/elif/elif...` が3段以上 → dict ディスパッチや early return を検討する
- ネストが3段以上 → ガード節（early return）でフラットにする
- 否定条件を避ける — `if not is_invalid` より `if is_valid` の方が読みやすい
- 同じ引数の組み合わせを複数の関数に渡している → その引数群はオブジェクトにまとめるべきサイン

## リファクタリングチェックリスト

GREEN（テスト通過）後、各変更でテストを再実行してリグレッションがないことを確認する:

- [ ] 重複コード: コピペで抽出すべき箇所はないか？
- [ ] デッドコード: 未使用のインポート、変数、関数、フィールドはないか？
- [ ] 命名: すべての名前が現在の振る舞いを正確に反映しているか？
- [ ] 制御フロー: 最もシンプルな形か？ early return でネストを減らせないか？否定条件を反転できないか？
- [ ] 抽象化レベル: 価値のない間接参照を追加しているヘルパーはないか？
- [ ] パターン一貫性: コードベースの他の部分と同じパターンに従っているか？
- [ ] コメント衛生: 最小限で、重複がなく、意図が非自明な箇所にのみ存在するか？
- [ ] 過剰な防御: 内部関数に不要なバリデーションや、ありえない状態のガード句がないか？
- [ ] 関数シグネチャ: 引数が多すぎないか？同じ引数群が複数関数に渡されていないか？
