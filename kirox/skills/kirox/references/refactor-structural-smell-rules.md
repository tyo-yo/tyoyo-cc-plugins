# 構造スメルリファクタルール

REFACTOR フェーズで「修正」ではなく「検知」に全振りするためのルール。
誤検知を許容して見逃しを減らす。

## 目的

- 違和感を最大量で掘り起こす
- 「そもそも不要実装」の仮説を必ず出す
- 既存パターンとのズレを特定する
- 標準ライブラリや既存フレームワーク機能への置換可能性を検知する

## 実行ルール

- 修正案の提示は後回しにして、まず検知のみを行う
- 精度より再現率を優先し、迷った指摘も出す
- すべての指摘に根拠のコード位置を付ける
- すべての指摘に「将来壊れるシナリオ」を1行で付ける
- すべてのモジュールで「削除可能性」の仮説を最低1件出す
- 代替案がなくても課題の指摘だけで良い

## 検知タスク

- 削除可能性検知: この関数、分岐、層は消しても責務が成立するか
- 境界違反検知: バリデーション、例外、型変換、状態管理がレイヤー越境していないか
- 一貫性破綻検知: 同一リポジトリの類似実装と命名、責務分割、エラーパターンがズレていないか
- 再実装検知: 標準ライブラリ、既存フレームワーク、定番ライブラリの機能を手作りしていないか
- 将来脆弱性検知: 仕様追加で壊れやすい形になっていないか

## スメルタイプ

- speculative-generality: 将来のためだけの先回り抽象化
- fake-abstraction: 実装が1つしかない抽象
- single-use-helper: 呼び出しが1箇所のヘルパー
- redundant-validation: 境界外での再バリデーション
- optional-inflation: 不要な Optional
- boolean-flag-api: 真偽値引数で責務が分岐
- parameter-clump: 同じ引数群の繰り返し
- control-flow-labyrinth: if/elif の迷路化
- deep-nesting: 深すぎるネスト
- exception-erasure: 例外情報の欠落
- log-and-swallow: ログのみで握りつぶし
- silent-fallback: 無言デフォルトフォールバック
- non-idempotent-retry: 危険なリトライ
- state-leak: 隠れ状態への依存
- naming-drift: 命名と実態の乖離
- comment-lie: コメントと実装の不一致
- framework-bypass: 既存フレームワーク機能の迂回
- stdlib-reimplementation: 標準機能の再実装
- transport-type-leak: 境界の型が内部へ侵食
- dead-compat-branch: 死んだ後方互換分岐
- copy-rule-divergence: 同一ルールの重複実装
- pseudo-domain-layer: 層はあるが責務が空
- over-normalization: 分割しすぎによる理解コスト増
- premature-async: 不要な非同期化
- temporal-coupling: 呼び順依存

## どんでん返しの問い

- これは本当に存在に値するか
- これを全部消しても要件を満たせない理由は何か
- この責務は1つ上か1つ下のレイヤーに寄せるべきではないか
- フレームワーク既存機能に戻したら何行消えるか
- 状態を減らして値を返す形に倒せないか

## LLM への指示文

- あなたの仕事は修正ではなく検知。誤検知を許容して見逃しを最小化せよ。
- 各ファイルで不要実装、境界違反、一貫性破綻、再実装を優先して探せ。
- すべての指摘に根拠位置と将来破綻シナリオを付けよ。
- 修正案はまだ書くな。違和感を最大数列挙せよ。
